---
title: Overview
description: Learn how Holos integrates software into a holistic platform.
---

import RenderingOverview from '../diagrams/rendering-overview.mdx';
import RenderPlatformDiagram from '../diagrams/render-platform-sequence.mdx';
import RenderComponentDiagram from '../diagrams/render-component-sequence.mdx';

# Tutorial

Holos is an open-source configuration management tool for Kubernetes resources,
designed to simplify software integration for platform teams. It supports a wide range of
configurations, from managing large, multi-cluster platforms across regions to
generating a single resource on a local device.

{/* truncate */}

At a high level, Holos provides a few major components:

- A Platform schema for specifying how components integrate together into a platform.
- Component building blocks for Helm, Kustomize, and Kubernetes to unify configuration with CUE.
- A BuildPlan orchestrating generators, transformers, and validators to produce manifest files.

<RenderingOverview />

## Holos' role in your organization

Platform engineers use the `holos render platform` command locally or in CI to
generate Kubernetes manifests, which are then committed to version control.
GitOps tools like ArgoCD or Flux handle the deployment of these manifests.

Unlike most Kubernetes tools that focus solely on application management, Holos
takes a holistic approach, targeting the integration layer where applications
and organizational data converge. Its well-defined, typed structures ensure
consistent validation, reducing errors, streamlining integration, and providing
clear pathways for teams to integrate their services.

Holos focuses on the platform as a whole rather than individual applications,
making it easy to see the impact of a single configuration change, like updating
a domain name, across the entire system. Whether generating a single ConfigMap
or producing millions of lines of manifests for multiple environments, clusters,
and regions, Holos ensures platform-wide consistency and visibility.

<RenderPlatformDiagram />

## Advantages of Holos

This section outlines some advantages of Holos.

### Safe

* [CUE] provides strong typing and constraints for Holos Components that surface
validation errors early in the development process, reducing the number of
failed deployments and the time spent troubleshooting them.
* Holos natively provides a "blast radius" to code
changes by identifying the rendered manifests across your fleet of Kubernetes
clusters that will be affected by the change.
* [CUE's][CUE] unification strategy allows multiples teams to contribute to the desired
state of a service:
    * The Platform team provides definitions for shared resources.
    * Engineering teams populate definitions with service-specific data.
    * The Security team provides concrete values that cannot be changed to harden the company's security posture.

### Consistent

* Holos manages the execution context for Helm and Kustomize, ensuring that
rendered manifests are consistently and reliably reproducible, no matter where
Holos is run.
* CUE constraints ensure that data abstractions include the required information
in the expected format, triggering early failures if any required data is
missing.

### Flexible

* [CUE] is adept at modeling variation and organizational complexity at scale,
while Holos enables seamless integration of [CUE] data with native Kubernetes
tools such as [Helm] and [Kustomize].
* Holos is extensible, allowing Holos Components to be modeled from any tool that
generates (e.g. `helm`) or transforms (e.g.  `kustomize`) manifest data.

Holos does not have an opinion on many common aspects of platform configuration.
For example, environments and clusters are explicitly kept out of the core and
instead are provided as flexible, user-customizable [topics] organized as a
recipes.

<RenderComponentDiagram />

## When not to use Holos

Although Holos is useful for many organizations that need to do manage
configuration, there are also some use-cases where Holos is not a good fit.

### Implicit GitOps

Holos takes an explicit view of GitOps, meaning the fully rendered manifests are
complete.  These manifests are stored in version control without an implicit
dependency on external systems.  If your team uses an implicit approach, meaning
some configuration comes from elsewhere, then Holos may not be a good fit.

For example, if container image tags are managed by a system outside of version
control then holos may not be a good fit.

Holos is a good fit if you're open to integrate external systems with Holos such
that the external data becomes an input to produce the fully rendered manifests.

### CUE is a Non Starter

Holos heavily uses CUE.  For example, when using Holos with Helm and Kustomize,
we no longer need to write YAML files and text templates.  All configuration is
expressed in CUE and `holos` handles the YAML on our behalf.

CUE is a relatively simple domain specific language, but it is very different
from most other languages because of it's roots in logic programming languages.

Holos is not a good fit if your team prefers to write code in YAML templates or
turing complete general purpose languages.

For more info see [Why CUE for Configuration].

## Getting Help

If you get stuck, you can get help on [Discord] or [GitHub discussions].  Don't
worry about asking "beginner" questions, configuration is often complex even for
the most experienced among us.  We all start somewhere and are happy to help.

[rendered manifests pattern]: https://akuity.io/blog/the-rendered-manifests-pattern
[CUE]: https://cuelang.org/
[Helm]: https://helm.sh/
[Kustomize]: https://kustomize.io/
[Discord]: https://discord.gg/JgDVbNpye7
[GitHub discussions]: https://github.com/holos-run/holos/discussions
[Why CUE for Configuration]: https://holos.run/blog/why-cue-for-configuration/
[topics]: ../topics.mdx
